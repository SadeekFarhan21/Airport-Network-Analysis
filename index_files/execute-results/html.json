{
  "hash": "5cc73ce9f443d2affdf4d28882334372",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Airport Network Analysis\"\nsubtitle: \"Ego Networks & Global Flight Connectivity\"\nauthor: \"Farhan Sadeek\"\ndate: \"February 21, 2026\"\nformat: \n  html:\n    theme: cosmo\n    toc: true\n    toc-depth: 3\n    code-tools: true\n    code-overflow: wrap\n    embed-resources: false\n    echo: true\n    smooth-scroll: true\n    fig-align: center\necho: true\neditor: visual\n---\n\n```{=html}\n<style>\n@import url('https://fonts.googleapis.com/css2?family=Source+Sans+3:wght@300;400;500;600;700&display=swap');\n@import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap');\n\nbody {\n  font-family: 'Source Sans 3', 'Segoe UI', Roboto, sans-serif !important;\n  font-size: 17px;\n  line-height: 1.7;\n  color: #333;\n}\n\n/* headings */\nh1, h2, h3, h4, h5, h6 {\n  font-family: 'Source Sans 3', sans-serif !important;\n  color: #1b2a4a;\n}\nh1.title { font-size: 2.4rem; font-weight: 700; }\n.subtitle { font-size: 1.2rem; color: #5a6f8f; margin-top: -0.5rem; }\nh1 { font-size: 1.9rem; font-weight: 700; margin-top: 2.5rem; padding-bottom: 0.3rem; border-bottom: 2px solid #3b82f6; }\nh2 { font-size: 1.55rem; font-weight: 600; margin-top: 2rem; padding-bottom: 0.25rem; border-bottom: 1px solid #ddd; }\nh3 { font-size: 1.25rem; font-weight: 600; color: #374d6b; margin-top: 1.5rem; }\n\n/* paragraphs and lists */\np, li, td, th, .summary-highlight {\n  font-family: 'Source Sans 3', sans-serif !important;\n}\n\n/* code */\npre, code {\n  font-family: 'Fira Code', 'Consolas', monospace !important;\n  font-size: 13px;\n}\npre.sourceCode {\n  background: #f0f4fa;\n  border: 1px solid #c9d5e8;\n  border-left: 3px solid #3b82f6;\n  border-radius: 0 6px 6px 0;\n  padding: 0.9rem 1rem;\n}\ncode:not(pre code) {\n  background: #e8eef8;\n  padding: 0.1rem 0.35rem;\n  border-radius: 3px;\n  font-size: 0.88em;\n  color: #1b2a4a;\n}\n\n/* tables */\ntable {\n  font-size: 0.93rem;\n  margin: 1.2rem 0;\n}\nthead th {\n  background: #1b2a4a !important;\n  color: #fff !important;\n  font-weight: 600;\n  padding: 0.55rem 0.8rem;\n}\ntbody td {\n  padding: 0.45rem 0.8rem;\n}\ntbody tr:nth-child(even) { background: #f8f9fb; }\ntbody tr:hover { background: #e8f0fe; }\ntable caption {\n  color: #666;\n  font-style: italic;\n  font-size: 0.88rem;\n  caption-side: top;\n  margin-bottom: 0.4rem;\n}\n\n/* plots */\n.cell-output-display img {\n  border-radius: 6px;\n  border: 1px solid #e5e7eb;\n  margin: 0.8rem auto;\n  display: block;\n}\n\n/* summary callout box */\n.summary-highlight {\n  background: #f0f7ff;\n  border-left: 4px solid #3b82f6;\n  padding: 1rem 1.3rem;\n  border-radius: 0 6px 6px 0;\n  margin: 1.5rem 0;\n  color: #333;\n}\n.summary-highlight p {\n  margin-bottom: 0.5rem;\n}\n\n/* horizontal rule */\nhr {\n  border: none;\n  border-top: 1px solid #ddd;\n  margin: 2.5rem 0;\n}\n\n/* keep bold readable */\nstrong { color: #1b2a4a; }\n</style>\n```\n\n\n\n# Summary\n\n::: summary-highlight\nI had to split this computational notebook into two parts, the first part is about my own ego network and the second is about the dataset I picked about airport and the interconnected networks between them. For the first part I analyzed my personal **ego network** using McCabe's framework with the three attributes density, transitivity, betweenness, and modularity to understand how I am connected with different social groups. Since I travel a lot and mostly by air the second is a large-scale **flight network** from global aviation data using a random sample of 500 airports, then I used descriptive analysis techniques from Kolaczyk and Csárdi's *Statistical Analysis of Network Data with R* to understand some partterns in graph and networks.\n:::\n\n## Ego Network\n\nI will start off with the definition of **ego network**. An ego network tries to gather more information about the local neighborhood around a single node. In the ego network of my life, I am the **ego**, its direct connections (the **alters**), and the connections between them. According to McCabe (2016), ego networks are a fundamental unit of social network analysis because they represent the immediate social environment of an individual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Reading and building the ego network\nego_net_link = \"https://notes.farhansadeek.com/dartmouth/math7/homework/Ego_Network.csv\"\nego <- read.csv(ego_net_link)\nego_network <- simplify(graph_from_data_frame(ego, directed = FALSE))\n```\n:::\n\n\n### Visualizing the Ego Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Ego node setup\nego_node <- \"FS\"\n\n## Color and size: ego vs alters (Claude Code)\nnode_colors <- ifelse(V(ego_network)$name == ego_node, \"tomato\", \"steelblue\")\nnode_sizes <- ifelse(V(ego_network)$name == ego_node, 12, 7)\n\nlayout_fr <- layout_with_fr(ego_network)\n\n## Plot the ego network (Claude Code)\nplot(ego_network,\n     layout = layout_fr,\n     vertex.size = node_sizes,\n     vertex.color = node_colors,\n     vertex.frame.color = \"white\",\n     vertex.label.family = \"sans\",\n     vertex.label.color = \"black\",\n     vertex.label.dist = 1.5,\n     vertex.label.cex = 0.8,\n     edge.arrow.size = 0.4,\n     edge.curved = 0.2,\n     edge.color = adjustcolor(\"gray70\", alpha.f = 0.5),\n     main = \"Personal Ego Network\")\n\nlegend(\"bottomright\", legend = c(\"Ego (FS)\", \"Alters\"),\n       pt.bg = c(\"tomato\", \"steelblue\"), col = \"white\",\n       pch = 21, pt.cex = 1.5, bty = \"n\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ego-viz-1.png){width=672}\n:::\n:::\n\n\nIn my ego network, I am the node connecting many otherwise disconnected people. If we look at the visualization, then it's clear that I am connected to many alters and alters are not very well connected to themselves. Now, this is very common in ego networks, where the ego serves as a central hub bridging otherwise disconnected groups.\n\n### Full Ego Network Measures\n\nNow I will calculate the main structural metrics for the **complete ego network**, which includes all ties between the me and the edges that I am connected to, as well as any connections among the my friends themselves. This would allow us to understand communities and the imapact of me in the ego network formed because of me.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Computing full ego network measures\nfull_density <- igraph::edge_density(ego_network)\nfull_transitivity_global <- igraph::transitivity(ego_network, type = \"global\")\nfull_transitivity_ego <- igraph::transitivity(ego_network, type = \"local\",\n                          vids = which(V(ego_network)$name == ego_node))\nfull_betweenness <- igraph::betweenness(ego_network)\nfull_fc <- igraph::cluster_fast_greedy(ego_network)\nfull_modularity <- igraph::modularity(full_fc)\n\n## Summary table\nfull_measures <- data.frame(\n  Measure = c(\"Nodes\", \"Edges\", \"Ego Degree (number of alters)\",\n              \"Density\", \"Global Transitivity\",\n              \"Local Transitivity of Ego\",\n              \"Betweenness Centrality of Ego\",\n              \"Normalized Ego Betweenness\",\n              \"Number of Communities\", \"Modularity\",\n              \"Ego's Community\"),\n  Value = c(vcount(ego_network),\n            ecount(ego_network),\n            igraph::degree(ego_network, v = ego_node),\n            round(full_density, 4),\n            round(full_transitivity_global, 4),\n            round(full_transitivity_ego, 4),\n            round(full_betweenness[ego_node], 2),\n            round(full_betweenness[ego_node] / max(full_betweenness), 4),\n            length(full_fc),\n            round(full_modularity, 4),\n            membership(full_fc)[ego_node])\n)\n\nkable(full_measures, col.names = c(\"Measure\", \"Value\"), align = c(\"l\", \"r\"))\n```\n\n::: {.cell-output-display}\n\n\n|Measure                       |    Value|\n|:-----------------------------|--------:|\n|Nodes                         |  34.0000|\n|Edges                         |  85.0000|\n|Ego Degree (number of alters) |  30.0000|\n|Density                       |   0.1515|\n|Global Transitivity           |   0.2786|\n|Local Transitivity of Ego     |   0.0920|\n|Betweenness Centrality of Ego | 380.5300|\n|Normalized Ego Betweenness    |   1.0000|\n|Number of Communities         |   2.0000|\n|Modularity                    |   0.2989|\n|Ego's Community               |   2.0000|\n\n\n:::\n:::\n\n\nSince I am the ego I am the center of the network directly connected to almost all other nodes; the network as a whole is moderately dense given its size, but alters have relatively low connectivity amongst themselves, indicated by the comparatively low local transitivity for the ego. My betweenness centrality is maximized showing that I am the main bridge in the network, and most communication flows through me. Since the modularity is high it means that that there might have some clustering among the alters desite me being the center of the network.\n\n### Alter-Only Network (Ego Removed)\n\nNow I will have to remove the ego node to create the **alter-only induced subgraph** that has only the alter-alter edges. Now, this is important because it shows us how connected the alters are to each other *without* the ego serving as a bridge.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Remove ego to get alter-only network\nalter_network <- igraph::delete_vertices(ego_network, which(V(ego_network)$name == ego_node))\n## Alter-only network measures\nalter_density <- igraph::edge_density(alter_network)\nalter_transitivity_global <- igraph::transitivity(alter_network, type = \"global\")\nalter_connected <- igraph::is_connected(alter_network)\nalter_n_components <- igraph::components(alter_network)$no\nalter_fc <- igraph::cluster_louvain(alter_network)\nalter_modularity <- igraph::modularity(alter_fc)\n\nalter_measures <- data.frame(\n  Measure = c(\"Nodes\", \"Edges\", \"Density\", \"Global Transitivity\",\n              \"Is Connected\", \"Number of Components\",\n              \"Number of Communities\", \"Modularity\"),\n  Value = c(vcount(alter_network),\n            ecount(alter_network),\n            round(alter_density, 4),\n            round(alter_transitivity_global, 4),\n            alter_connected,\n            alter_n_components,\n            length(alter_fc),\n            round(alter_modularity, 4))\n)\n\nkable(alter_measures, col.names = c(\"Measure\", \"Value\"), align = c(\"l\", \"r\"))\n```\n\n::: {.cell-output-display}\n\n\n|Measure               |   Value|\n|:---------------------|-------:|\n|Nodes                 | 33.0000|\n|Edges                 | 55.0000|\n|Density               |  0.1042|\n|Global Transitivity   |  0.3666|\n|Is Connected          |  0.0000|\n|Number of Components  |  9.0000|\n|Number of Communities | 11.0000|\n|Modularity            |  0.3734|\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Visualize alter-only network by community\nn_communities <- max(alter_fc$membership)\npal <- if (n_communities <= 12) brewer.pal(max(3, n_communities), \"Set3\") else rainbow(n_communities)\nalter_node_colors <- pal[alter_fc$membership]\n\nplot(alter_network,\n     vertex.size = 8,\n     vertex.color = alter_node_colors,\n     vertex.frame.color = \"white\",\n     vertex.label.family = \"sans\",\n     vertex.label.color = \"black\",\n     vertex.label.dist = 1.5,\n     vertex.label.cex = 0.8,\n     edge.arrow.size = 0.4,\n     edge.curved = 0.2,\n     edge.color = adjustcolor(\"gray80\", alpha.f = 0.4),\n     layout = layout_with_fr(alter_network),\n     main = \"Alter-Only Network (Colored by Community)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/alter-viz-1.png){width=672}\n:::\n:::\n\n\n### Comparison Table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- data.frame(\n  Measure = c(\"Nodes\", \"Edges\", \"Density\", \"Global Transitivity\", \"Modularity\", \"Communities\"),\n  Full_w_ego = c(vcount(ego_network), ecount(ego_network), full_density, full_transitivity_global, full_modularity, length(full_fc)),\n  Alter_only = c(vcount(alter_network), ecount(alter_network), alter_density, alter_transitivity_global, alter_modularity, length(alter_fc))\n)\n\nkable(results, col.names = c(\"Measure\", \"Full (w/ ego)\", \"Alter-only\"), digits = 4)\n```\n\n::: {.cell-output-display}\n\n\n|Measure             | Full (w/ ego)| Alter-only|\n|:-------------------|-------------:|----------:|\n|Nodes               |       34.0000|    33.0000|\n|Edges               |       85.0000|    55.0000|\n|Density             |        0.1515|     0.1042|\n|Global Transitivity |        0.2786|     0.3666|\n|Modularity          |        0.2989|     0.3734|\n|Communities         |        2.0000|    11.0000|\n\n\n:::\n:::\n\n\n### McCabe's Network Typology\n\nAccording to the McCabe, there are three types of network structure - **Tight-knitters** have one densely connected, often exclusive group (high density, high transitivity, low modularity) - **Compartmentalizers** maintain distinct, separate groups that do not mingle (moderate density, high modularity, multiple clear communities). - **Samplers** maintain separate individual or small-group friendships across different areas of life (low density, low transitivity, many components or isolates in the alter-only network).\n\nI can classify my ego network by examining the structural signatures in the alter-only network, since that reveals the true pattern of connections among my contacts without me as the bridge.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Gemini 3.1 Pro\ntypology_metrics <- data.frame(\n  Metric = c(\"Alter-only density\", \"Alter-only transitivity\",\n             \"Alter-only modularity\", \"Number of communities\",\n             \"Number of components\"),\n  Value = c(round(alter_density, 4),\n            round(alter_transitivity_global, 4),\n            round(alter_modularity, 4),\n            length(alter_fc),\n            alter_n_components)\n)\n\nkable(typology_metrics, col.names = c(\"Metric\", \"Value\"), align = c(\"l\", \"r\"),\n      caption = \"Alter-Only Network Metrics for Typology Classification\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Alter-Only Network Metrics for Typology Classification\n\n|Metric                  |   Value|\n|:-----------------------|-------:|\n|Alter-only density      |  0.1042|\n|Alter-only transitivity |  0.3666|\n|Alter-only modularity   |  0.3734|\n|Number of communities   | 11.0000|\n|Number of components    |  9.0000|\n\n\n:::\n\n```{.r .cell-code}\n## Classification logic based on McCabe (2016)\nif (alter_density > 0.3 && alter_modularity < 0.3) {\n  ego_type <- \"Tight-knitter\"\n} else if (alter_density < 0.15 && alter_n_components > 3) {\n  ego_type <- \"Sampler\"\n} else {\n  ego_type <- \"Compartmentalizer\"\n}\n```\n:::\n\n\nBased on these metrics, I classify as a **Sampler**. Here is the the pattern that I noticed there was\n\n-   A **Tight-knitter** would show alter-only density above 0.3 and modularity below 0.3 — one big, tightly connected group where everyone knows everyone.\n-   A **Sampler** would show very low alter-only density (below 0.15) and many disconnected components (more than 3) — scattered friendships that don't form groups.\n-   A **Compartmentalizer** falls in between: the alter-only network has moderate density with clear community structure (high modularity) — distinct friend groups (e.g., academic, extracurricular, home) that don't overlap much.\n\nWith an alter-only density of 0.1042, modularity of 0.3734, and 9 components, my network fits the **Sampler** pattern. My contacts are mostly individual friendships rather than tight groups. Without me as the connector, many alters become isolated or form very small clusters.\n\n### Alter Role Classification\n\nNow [Gemini](https://gemini.google.com) also classified each alter by their structural role within the network. An alter's degree, local clustering coefficient, and betweenness centrality together reveal whether they sit inside a tight group, serve as a bridge between groups, or are relatively isolated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Classifying each alter by their structural role\nalter_names <- V(alter_network)$name\nalter_deg <- igraph::degree(alter_network)\nalter_local_trans <- igraph::transitivity(alter_network, type = \"local\")\nalter_betw <- igraph::betweenness(alter_network, normalized = TRUE)\nalter_community <- membership(alter_fc)\n\nalter_classification <- data.frame(\n  Alter = alter_names,\n  Degree = alter_deg,\n  Local_Clustering = round(alter_local_trans, 4),\n  Betweenness = round(alter_betw, 4),\n  Community = alter_community\n)\n\n## Assigning roles based on degree, clustering, and betweenness\nalter_classification$Role <- ifelse(\n  alter_deg == 0, \"Isolate\",\n  ifelse(alter_betw > median(alter_betw[alter_betw > 0], na.rm = TRUE) &\n         alter_deg >= median(alter_deg[alter_deg > 0]),\n         \"Bridge\",\n         ifelse(!is.na(alter_local_trans) & alter_local_trans > 0.5,\n                \"Tight-knit member\",\n                \"Peripheral\")))\n\nkable(alter_classification |> arrange(desc(Degree)),\n      col.names = c(\"Alter\", \"Degree\", \"Local Clustering\", \"Betweenness\",\n                     \"Community\", \"Role\"),\n      align = c(\"l\", \"r\", \"r\", \"r\", \"r\", \"l\"),\n      caption = \"Alter Classification by Network Role\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Alter Classification by Network Role\n\n|    |Alter | Degree| Local Clustering| Betweenness| Community|Role              |\n|:---|:-----|------:|----------------:|-----------:|---------:|:-----------------|\n|JX  |JX    |     13|           0.2692|      0.1319|         1|Bridge            |\n|MM  |MM    |     12|           0.2424|      0.2092|         2|Bridge            |\n|KRM |KRM   |      8|           0.2500|      0.0862|         3|Bridge            |\n|AC  |AC    |      8|           0.2500|      0.0862|         3|Bridge            |\n|AZ  |AZ    |      7|           0.3810|      0.0821|         2|Bridge            |\n|NB  |NB    |      6|           0.6000|      0.0077|         2|Tight-knit member |\n|AT  |AT    |      6|           0.6667|      0.0042|         2|Tight-knit member |\n|EB  |EB    |      6|           0.5333|      0.0165|         1|Tight-knit member |\n|AP  |AP    |      5|           0.4000|      0.0411|         1|Peripheral        |\n|KC  |KC    |      4|           1.0000|      0.0000|         2|Tight-knit member |\n|YG  |YG    |      4|           0.8333|      0.0004|         2|Tight-knit member |\n|AKC |AKC   |      4|           0.1667|      0.0868|         3|Bridge            |\n|EZ  |EZ    |      3|           0.6667|      0.0010|         1|Tight-knit member |\n|MX  |MX    |      3|           0.3333|      0.0549|         3|Peripheral        |\n|AK  |AK    |      3|           0.3333|      0.0549|         3|Peripheral        |\n|MS  |MS    |      2|           1.0000|      0.0000|         1|Tight-knit member |\n|SC  |SC    |      2|           1.0000|      0.0000|         1|Tight-knit member |\n|BW  |BW    |      2|           1.0000|      0.0000|         1|Tight-knit member |\n|TW  |TW    |      2|           1.0000|      0.0000|         3|Tight-knit member |\n|EW  |EW    |      2|           1.0000|      0.0000|         3|Tight-knit member |\n|RH  |RH    |      2|           1.0000|      0.0000|         3|Tight-knit member |\n|JZ  |JZ    |      2|           1.0000|      0.0000|         3|Tight-knit member |\n|SN  |SN    |      2|           1.0000|      0.0000|         1|Tight-knit member |\n|CZ  |CZ    |      1|              NaN|      0.0000|         2|Peripheral        |\n|KMC |KMC   |      1|              NaN|      0.0000|         2|Peripheral        |\n|IC  |IC    |      0|              NaN|      0.0000|         4|Isolate           |\n|HB  |HB    |      0|              NaN|      0.0000|         5|Isolate           |\n|SK  |SK    |      0|              NaN|      0.0000|         6|Isolate           |\n|CG  |CG    |      0|              NaN|      0.0000|         7|Isolate           |\n|MA  |MA    |      0|              NaN|      0.0000|         8|Isolate           |\n|JS  |JS    |      0|              NaN|      0.0000|         9|Isolate           |\n|JC  |JC    |      0|              NaN|      0.0000|        10|Isolate           |\n|MH  |MH    |      0|              NaN|      0.0000|        11|Isolate           |\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(7, 5, 2, 3))  # increase bottom margin\nrole_summary <- table(alter_classification$Role)\nbarplot(sort(role_summary, decreasing = TRUE),\n        col = \"steelblue\",\n        las = 2,\n        cex.names = 0.8,\n        ylab = \"Number of Alters\",\n        main = \"Distribution of Alter Roles in Ego Network\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/alter-role-barplot-1.png){width=672}\n:::\n:::\n\n\nThe alter role distribution reinforces the Sampler classification. **Isolates** are alters who have no connections to anyone else in my network — they know only me, which is characteristic of sampler-type relationships. **Bridges** are alters with high betweenness who connect different groups, much like I do as the ego. **Tight-knit members** are embedded within a dense cluster where their neighbors are also connected to each other. **Peripheral** alters have some connections but don't fit neatly into a tight group or bridging role.\n\n### Comparison and Discussion\n\nNow if we compare the network with and without me then there are a few interesting patterns. The density drops noticeably when I was removed, and that makes sense because I am connected to every alter by definition. Transitivity also changes, meaning that many of my alters know each other only through me. The modularity in the alter-only network is higher, indicating that without me bridging the groups, the alters cluster into more distinct communities such as friend groups from different parts of my life (college, work, hometown) that have little overlap. Now, this is *consistent with McCabe's observation that ego removal often reveals the brokerage role the ego plays*. Now the betweenness centrality in the full network makes sure that I am a middle-man when connecting groups that would otherwise be disconnected.\n\n------------------------------------------------------------------------\n\n## Flight Network Analysis\n\n### Sampling from a Large Dataset\n\nNow, this is the second part of the computational notebook where I am taking a **random sample of 500 airports** from the global flight data. This gives us a more realistic and structurally interesting network with regional and smaller airports alongside major hubs. The network should show a variety of degree distribution and hub-and-spoke topology that is characteristic of real-world modern air transportation networks.\n\nI read a single month of global flight data (April 2020) and then drew my sample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Loading April 2020 flight data\ndf <- read.csv(\"dataset/flightlist_20200401_20200430.csv\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Counting flights per airport\norigin_counts <- df |> count(origin, name = \"flights\") |> rename(airport = origin)\ndest_counts <- df |> count(destination, name = \"flights\") |> rename(airport = destination)\nairport_activity <- bind_rows(origin_counts, dest_counts) |>\n  group_by(airport) |>\n  summarise(total_flights = sum(flights)) |>\n  arrange(desc(total_flights))\n\n## Remove airports with empty or NA codes\nairport_activity <- airport_activity |> filter(airport != \"\" & !is.na(airport))\n```\n:::\n\n\nI used a stratified random sampling approach to ensure the 500-airport sample includes a realistic mix with the very busiest hubs (so the network stays connected) alongside a random draw from the rest. This mirrors how real airline networks work a few major hubs connect to many smaller airports.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Randomly sample 500 airports\nset.seed(42)\n\nall_airports <- airport_activity$airport\nsampled_airports <- sample(all_airports, min(2000, length(all_airports)))\n\n## Filter to flights between sampled airports\nsampled_df <- df |> filter(origin %in% sampled_airports & destination %in% sampled_airports)\n\ncat(\"Number of sampled airports:\", length(sampled_airports), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of sampled airports: 2000 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Number of flights between sampled airports:\", nrow(sampled_df), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of flights between sampled airports: 33675 \n```\n\n\n:::\n:::\n\n\n### Building the Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Selecting relevant columns\nsampled_df <- sampled_df |>\n  select(origin, destination, latitude_1, longitude_1, latitude_2, longitude_2) |>\n  drop_na()\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Edge list: weighted by flight count per route\nedges <- sampled_df |>\n  group_by(origin, destination) |>\n  summarise(weight = n(), .groups = \"drop\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Vertex list: unique airports with coordinates\norigins <- sampled_df |>\n  select(name = origin, lat = latitude_1, long = longitude_1)\n\ndestinations <- sampled_df |>\n  select(name = destination, lat = latitude_2, long = longitude_2)\n\nnodes <- bind_rows(origins, destinations) |>\n  distinct(name, .keep_all = TRUE) |>\n  na.omit()\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Building the directed graph\nflight_network <- graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE)\nflight_network <- simplify(flight_network, remove.multiple = TRUE, remove.loops = TRUE)\n\n## Undirected version for symmetric analyses\nflight_undirected <- igraph::as.undirected(flight_network, mode = \"collapse\")\n\ncat(\"Directed network:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDirected network:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(summary(flight_network))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH 4b96c13 DNW- 1342 3713 -- \n+ attr: name (v/c), lat (v/n), long (v/n), weight (e/n)\nIGRAPH 4b96c13 DNW- 1342 3713 -- \n+ attr: name (v/c), lat (v/n), long (v/n), weight (e/n)\n+ edges from 4b96c13 (vertex names):\n [1] OTHH->VABB OTHH->KIAD OTHH->RJBB OTHH->LEMD OTHH->KJFK OTHH->VTBS\n [7] OTHH->EBLG OTHH->KDFW OTHH->EGSS OTHH->LIRF OTHH->WSAP OTHH->GMMN\n[13] OTHH->LOWW OTHH->UKBB OTHH->LEBL OTHH->VOMM OTHH->ENKJ OTHH->EDDT\n[19] OTHH->RJAA OTHH->EINN OTHH->LKVO OTHH->FARA OTHH->UKKT VABB->OTHH\n[25] VABB->EBLG VABB->WSAP VABB->VOMM VABB->VTBD VABB->VAPO VABB->VEPI\n[31] KIAD->OTHH KIAD->LEMD KIAD->KJFK KIAD->KCLT KIAD->KCLE KIAD->KDFW\n[37] KIAD->KDAL KIAD->KMKE KIAD->KFCM KIAD->KTPA KIAD->KRVS KIAD->KLAS\n[43] KIAD->KDTW KIAD->03PS KIAD->KX04 KIAD->KFTW KIAD->KBUY KIAD->KORF\n+ ... omitted several edges\n```\n\n\n:::\n:::\n\n\nI selected only the columns needed for the analysis, constructed edge and vertex lists, and built both directed and undirected versions of the graph. I then simplified the graph so that there are no multi-edges or self-loops (the edge list was already aggregated by route, but simplification ensures a simple graph and removes any self-loops).\n\n### Network Visualization\n\nI visualized the network using a force-directed layout. In a network this large, raw plots can become unreadable, so I used vertex size scaled by degree and edge transparency to highlight the hub-and-spoke structure. I also applied the Fruchterman-Reingold layout algorithm (Fruchterman & Reingold, 1991), which tends to place highly-connected nodes centrally.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Claude Code generated visualization with packcircles for better layoutated \ndeg <- igraph::degree(flight_undirected)\nbtw <- igraph::betweenness(flight_undirected)\n\ndf <- data.frame(\n  airport = V(flight_undirected)$name,\n  centrality = btw,\n  degree = deg\n)\n\n# Aggressive cleaning\ndf <- df[complete.cases(df), ]\ndf <- df[df$centrality > 0, ]\ndf <- df[is.finite(df$centrality), ]\ndf$centrality <- as.numeric(df$centrality)\n\ncolor_pal <- colorRampPalette(c(\"lightblue\", \"steelblue\", \"darkblue\", \"orange\", \"red\"))(5)\n## Use unique breaks so cut() never gets duplicate break points (e.g. when degree has little variation)\ndeg_breaks <- unique(quantile(df$degree, probs = seq(0, 1, length.out = 6), na.rm = TRUE))\nif (length(deg_breaks) >= 2) {\n  df$deg_bin <- as.integer(cut(df$degree, breaks = deg_breaks, include.lowest = TRUE, labels = FALSE))\n  df$deg_bin <- pmin(df$deg_bin, 5)  # cap at 5 for color_pal\n} else {\n  df$deg_bin <- 1L\n}\ndf$color   <- color_pal[df$deg_bin]\ndf$label   <- ifelse(df$centrality >= quantile(df$centrality, 0.90), df$airport, \"\")\n\n# Pack and check for NAs before plotting\npacking <- circleProgressiveLayout(df$centrality, sizetype = \"area\")\n\n# Drop any rows where packing produced NAs\nbad <- apply(packing, 1, function(r) any(is.na(r)))\ndf     <- df[!bad, ]\npacking <- packing[!bad, ]\n\ndf <- cbind(df, packing)\ndat.gg <- circleLayoutVertices(packing, npoints = 100)\ndat.gg$deg_bin <- rep(df$deg_bin, each = 101)\n\nggplot() +\n  geom_polygon(data = dat.gg,\n               aes(x, y, group = id, fill = factor(deg_bin)),\n               colour = \"white\", linewidth = 0.3, alpha = 0.92) +\n  scale_fill_manual(\n    values = setNames(color_pal, as.character(1:5)),\n    labels = c(\"Very Low\", \"Low\", \"Medium\", \"High\", \"Very High\"),\n    name = \"Degree\"\n  ) +\n  geom_text(data = df[df$label != \"\", ],\n            aes(x, y, label = label, size = centrality),\n            color = \"white\", fontface = \"bold\", show.legend = FALSE) +\n  scale_size_continuous(range = c(2, 6)) +\n  coord_equal() +\n  theme_void() +\n  theme(\n    legend.position = \"right\",\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\"),\n    plot.background = element_rect(fill = \"white\", color = NA)\n  ) +\n  labs(title = \"Flight Network — Airport Centrality\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/flight-network-viz-1.png){width=960}\n:::\n:::\n\n\nFrom this visualization I can see the hub-and-spoke structure that airlines follow which is a small number of airports (colored in red/orange) sit at the center of the layout with many connections, while the majority of airports cluster around the periphery with only a few routes each.\n\n### Basic Graph Properties\n\nBelow are some basic network property checks designed with the help of [Claude Code](https://code.claude.com). These provide an overview of the network's structure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwc <- igraph::clusters(flight_network, mode = \"weak\")\n\nbasic_props <- data.frame(\n  Property = c(\"Number of airports (vertices)\",\n               \"Number of flight routes (edges)\",\n               \"Is the graph simple?\",\n               \"Is weakly connected?\",\n               \"Is strongly connected?\",\n               \"Number of weakly connected components\",\n               \"Size of largest component\",\n               \"Diameter (unweighted)\",\n               \"Average path length\",\n               \"Edge density\"),\n  Value = c(vcount(flight_network),\n            ecount(flight_network),\n            is_simple(flight_network),\n            is_connected(flight_network, mode = \"weak\"),\n            is_connected(flight_network, mode = \"strong\"),\n            wc$no,\n            max(wc$csize),\n            diameter(flight_network, weights = NA),\n            round(mean_distance(flight_network), 4),\n            round(edge_density(flight_network), 6))\n)\n\nkable(basic_props, col.names = c(\"Property\", \"Value\"), align = c(\"l\", \"r\"))\n```\n\n::: {.cell-output-display}\n\n\n|Property                              |      Value|\n|:-------------------------------------|----------:|\n|Number of airports (vertices)         | 1.3420e+03|\n|Number of flight routes (edges)       | 3.7130e+03|\n|Is the graph simple?                  | 1.0000e+00|\n|Is weakly connected?                  | 0.0000e+00|\n|Is strongly connected?                | 0.0000e+00|\n|Number of weakly connected components | 1.1700e+02|\n|Size of largest component             | 1.1370e+03|\n|Diameter (unweighted)                 | 1.6000e+01|\n|Average path length                   | 7.7486e+00|\n|Edge density                          | 2.0630e-03|\n\n\n:::\n:::\n\n\n## Vertex and Edge Characteristics\n\n### Degree Distribution\n\n\nNow we will take a look at the degree distribution, which is a very important property of the network. The degree distribution tells us how many connections each airport has. In airline networks, we often see a highly skewed degree distribution where a few major hubs have many connections, while most airports have only a few routes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\n\n## Histogram of degree\nhist(igraph::degree(flight_undirected),\n     col = \"steelblue\",\n     breaks = 50,\n     xlab = \"Vertex Degree\",\n     ylab = \"Frequency\",\n     main = \"Degree Distribution\")\n\n## Log-log degree distribution to check for power-law behavior\ndd.flights <- degree_distribution(flight_undirected)\nd <- 0:(length(dd.flights) - 1)\nind <- (dd.flights != 0)\nplot(d[ind], dd.flights[ind],\n     log = \"xy\",\n     col = \"steelblue\",\n     pch = 19,\n     xlab = \"Log-Degree\",\n     ylab = \"Log-Intensity\",\n     main = \"Log-Log Degree Distribution\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/flight-degree-dist-1.png){width=960}\n:::\n:::\n\n\nThe degree distribution is very skewed, because of the airports don't have very many connections, but the hubs have a lot of connections. The log-long plot shows a linear relationship in the tail, which is an indication of a power-law or scale-free degree distribution. Now we can derive becuase most airlines want to reduce cost and having only a few hubs make it easier for repair and maintenace.\n\n### Vertex Strength\n\nWhile degree counts the number of routes, vertex strength accounts for edge weights which could be represented the number of flights on each route. This could help us find airpots where are people flying a lot more frequently.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\nhist(igraph::degree(flight_undirected), col = \"lightblue\",\n     xlab = \"Vertex Degree\", ylab = \"Frequency\", main = \"Degree\",\n     breaks = 40)\n\nhist(strength(flight_undirected), col = \"steelblue\",\n     xlab = \"Vertex Strength (Total Flights)\", ylab = \"Frequency\",\n     main = \"Strength\", breaks = 40)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/flight-strength-1.png){width=960}\n:::\n:::\n\n\nBoth distributions are right-skewed, but the strength distribution has an even longer tail. Now this means that not only that the major hubs have more destinations those flights are much more frequent than the routes themselves.\n\n### Average Neighbor Degree\n\nLet's take a look at how each airport's number of connections relates to the average number of connections its neighboring airports have. This helps us see if airports with lots of connections mostly link to other well-connected airports, or if they're more likely to connect to smaller, less connected ones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na.nn.deg.flight <- knn(flight_undirected, V(flight_undirected))$knn\nplot(igraph::degree(flight_undirected), a.nn.deg.flight,\n     log = \"xy\",\n     col = adjustcolor(\"steelblue\", alpha.f = 0.5),\n     pch = 19,\n     xlab = \"Log Vertex Degree\",\n     ylab = \"Log Average Neighbor Degree\",\n     main = \"Degree vs. Average Neighbor Degree\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/flight-avg-neighbor-deg-1.png){width=672}\n:::\n:::\n\n\nThe plot shows a negative trend: higher-degree airports (the major hubs) tend to be connected to neighbors with lower average degree. This is textbook disassortative mixing, which is characteristic of hub-and-spoke transportation networks. The big hubs connect to many small regional airports, which in turn have the hub as their most prominent neighbor. This pattern contrasts with social networks, which are typically assortative (popular people befriend other popular people).\n\n## Network Cohesion\n\nNow, this an interesting property to look at how the vertex and edges are connected and the size of the largest component to understand how the network is built.\n\n### Connectivity and Components\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Vertex and edge connectivity\nv_conn <- igraph::vertex_connectivity(flight_undirected)\ne_conn <- igraph::edge_connectivity(flight_undirected)\n\ncomp <- igraph::clusters(flight_undirected)  # use clusters() to avoid the conflict\n\ncohesion_props <- data.frame(\n  Property = c(\"Vertex connectivity\",\n               \"Edge connectivity\",\n               \"Number of components\",\n               \"Size of largest component\",\n               \"Number of isolates (degree 0)\"),\n  Value = c(v_conn,\n            e_conn,\n            comp$no,\n            max(comp$csize),\n            sum(igraph::degree(flight_undirected) == 0))\n)\n\nkable(cohesion_props, col.names = c(\"Property\", \"Value\"), align = c(\"l\", \"r\"))\n```\n\n::: {.cell-output-display}\n\n\n|Property                      | Value|\n|:-----------------------------|-----:|\n|Vertex connectivity           |     0|\n|Edge connectivity             |     0|\n|Number of components          |   117|\n|Size of largest component     |  1137|\n|Number of isolates (degree 0) |    78|\n\n\n:::\n:::\n\n\nNow, since vertex connectivity and edge connectivity is 0, this means that this airport network is connected to every single other airport in some path. The \nVertex connectivity tells us the minimum number of airports whose removal would disconnect the network, while edge connectivity gives the minimum number of routes. In a hub-and-spoke network, these values are often low because removing just a few critical hubs can fragment the network, which has real implications for airline disruptions and resilience.\n\n### Transitivity (Clustering Coefficient)\n\nTransitivity, also called the clustering coefficient, measures the tendency for triangles to form in the network. In an airport context, a triangle means that if airport A has direct flights to both B and C, then B and C also have a direct flight between them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Global transitivity\nglobal_trans <- transitivity(flight_undirected, type = \"global\")\n\n## Local transitivity\nlocal_trans <- transitivity(flight_undirected, type = \"local\")\n\ncat(\"Global transitivity (clustering coefficient):\", round(global_trans, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGlobal transitivity (clustering coefficient): 0.1402 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Average local transitivity:\", round(mean(local_trans, na.rm = TRUE), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAverage local transitivity: 0.3549 \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Local clustering vs degree\nplot(igraph::degree(flight_undirected), local_trans,\n     col = adjustcolor(\"steelblue\", alpha.f = 0.4),\n     pch = 19,\n     xlab = \"Vertex Degree\",\n     ylab = \"Local Clustering Coefficient\",\n     main = \"Clustering Coefficient vs. Degree\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/flight-clustering-vs-degree-1.png){width=672}\n:::\n:::\n\n\nThe inverse relationship between degree and local clustering is a well-known phenomenon in scale-free networks (Kolaczyk & Csárdi, 2020, Sec. 4.2). High-degree hubs have low clustering because their many neighbors are mostly small airports that do not connect to each other — they all route through the hub. Small regional airports, on the other hand, may connect only to a few nearby hubs that are also interconnected, yielding higher local clustering.\n\n## Centrality Analysis\n\nCentrality measures identify the most important or influential nodes in a network. Following Kolaczyk and Csárdi (2020, Sec. 4.3), I computed four classic centrality measures, each capturing a different notion of \"importance.\"\n\n### Degree Centrality\n\nDegree centrality is the simplest measure: the number of direct connections. In an airport network, this tells us which airports serve the most direct routes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Degree centrality\ndeg_cent <- igraph::degree(flight_undirected)\n\n## Top 15 by degree\ntop_degree <- sort(deg_cent, decreasing = TRUE)[1:15]\nkable(data.frame(Airport = names(top_degree),\n                 Degree = as.integer(top_degree)),\n      col.names = c(\"Airport (ICAO)\", \"Degree\"),\n      align = c(\"l\", \"r\"),\n      caption = \"Top 15 Airports by Degree Centrality\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Top 15 Airports by Degree Centrality\n\n|Airport (ICAO) | Degree|\n|:--------------|------:|\n|KDFW           |    121|\n|KCLT           |    100|\n|KIAD           |     79|\n|KDAL           |     74|\n|KFTW           |     56|\n|KDTW           |     54|\n|KTPA           |     51|\n|KLAS           |     49|\n|KTUL           |     48|\n|KFCM           |     44|\n|KMKE           |     42|\n|KJFK           |     37|\n|KIWS           |     36|\n|KRVS           |     34|\n|EGSS           |     34|\n\n\n:::\n:::\n\n\n### Closeness Centrality\n\nCloseness centrality measures how close a node is to all other nodes, computed as the inverse of the average shortest path distance. Airports with high closeness are well-positioned to reach the entire network quickly — they are geographically or topologically central.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Closeness centrality on largest component\nlcc <- induced_subgraph(flight_undirected,\n                        which(comp$membership == which.max(comp$csize)))\nclose_cent <- igraph::closeness(lcc)\n\ntop_closeness <- sort(close_cent, decreasing = TRUE)[1:15]\nkable(data.frame(Airport = names(top_closeness),\n                 Closeness = round(as.numeric(top_closeness), 6)),\n      col.names = c(\"Airport (ICAO)\", \"Closeness\"),\n      align = c(\"l\", \"r\"),\n      caption = \"Top 15 Airports by Closeness Centrality\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Top 15 Airports by Closeness Centrality\n\n|Airport (ICAO) | Closeness|\n|:--------------|---------:|\n|KDFW           |  0.000213|\n|KIAD           |  0.000206|\n|KDAL           |  0.000202|\n|KTPA           |  0.000195|\n|KHWO           |  0.000195|\n|EGSS           |  0.000195|\n|KCLT           |  0.000195|\n|KFTW           |  0.000195|\n|6FD7           |  0.000195|\n|KRVS           |  0.000194|\n|KCLE           |  0.000192|\n|KFCM           |  0.000192|\n|3PS9           |  0.000192|\n|KNIP           |  0.000192|\n|KFDK           |  0.000191|\n\n\n:::\n:::\n\n\n### Betweenness Centrality\n\nBetweenness centrality counts the number of shortest paths between other pairs of nodes that pass through a given node. Airports with high betweenness are critical transfer points — if they shut down, many routes between other airports would be disrupted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbetw_cent <- igraph::betweenness(flight_undirected, normalized = TRUE)\n\ntop_betweenness <- sort(betw_cent, decreasing = TRUE)[1:15]\nkable(data.frame(Airport = names(top_betweenness),\n                 Betweenness = round(as.numeric(top_betweenness), 6)),\n      col.names = c(\"Airport (ICAO)\", \"Betweenness\"),\n      align = c(\"l\", \"r\"),\n      caption = \"Top 15 Airports by Betweenness Centrality\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Top 15 Airports by Betweenness Centrality\n\n|Airport (ICAO) | Betweenness|\n|:--------------|-----------:|\n|KDFW           |    0.135991|\n|KIAD           |    0.095267|\n|KDAL           |    0.078444|\n|KFTW           |    0.062871|\n|KCLT           |    0.059499|\n|EGSS           |    0.057008|\n|KFCM           |    0.048783|\n|KJFK           |    0.047787|\n|KTUL           |    0.044639|\n|KTPA           |    0.042151|\n|KLAS           |    0.041182|\n|IN60           |    0.035493|\n|KDTW           |    0.032096|\n|EINN           |    0.031980|\n|UDYZ           |    0.031221|\n\n\n:::\n:::\n\n\n### Eigenvector Centrality\n\nEigenvector centrality extends the idea of degree centrality by weighting connections: being connected to well-connected airports matters more than being connected to poorly-connected ones. This captures the recursive notion that an airport is important if it is connected to other important airports.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neig_cent <- eigen_centrality(flight_undirected)$vector\n\ntop_eigen <- sort(eig_cent, decreasing = TRUE)[1:15]\nkable(data.frame(Airport = names(top_eigen),\n                 Eigenvector = round(as.numeric(top_eigen), 6)),\n      col.names = c(\"Airport (ICAO)\", \"Eigenvector Centrality\"),\n      align = c(\"l\", \"r\"),\n      caption = \"Top 15 Airports by Eigenvector Centrality\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Top 15 Airports by Eigenvector Centrality\n\n|Airport (ICAO) | Eigenvector Centrality|\n|:--------------|----------------------:|\n|KDFW           |               1.000000|\n|KDTW           |               0.728641|\n|KCLT           |               0.697133|\n|KLAS           |               0.681991|\n|KIAD           |               0.531894|\n|KORF           |               0.382264|\n|KTUL           |               0.364943|\n|KCLE           |               0.293416|\n|KMKE           |               0.291355|\n|KDAL           |               0.285431|\n|KJFK           |               0.284070|\n|KTPA           |               0.273272|\n|KU42           |               0.232348|\n|KMFE           |               0.202292|\n|KMCF           |               0.195373|\n\n\n:::\n:::\n\n\n### Hub and Authority Scores\n\nFor directed networks,hub and authority scores provide a complementary perspective. An airport is a good **hub** if it sends flights to many good authorities, and a good **authority** if it receives flights from many good hubs. In aviation, hubs are airports that serve as major departure points and authorities are major arrival destinations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhub_scores <- hub_score(flight_network)$vector\nauth_scores <- authority_score(flight_network)$vector\n\ntop_hubs <- sort(hub_scores, decreasing = TRUE)[1:10]\ntop_auths <- sort(auth_scores, decreasing = TRUE)[1:10]\n\nkable(data.frame(Hub_Airport = names(top_hubs),\n                 Hub_Score = round(as.numeric(top_hubs), 4),\n                 Auth_Airport = names(top_auths),\n                 Auth_Score = round(as.numeric(top_auths), 4)),\n      col.names = c(\"Hub Airport\", \"Hub Score\", \"Authority Airport\", \"Authority Score\"),\n      align = c(\"l\", \"r\", \"l\", \"r\"),\n      caption = \"Top 10 Airports by Hub and Authority Scores\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Top 10 Airports by Hub and Authority Scores\n\n|Hub Airport | Hub Score|Authority Airport | Authority Score|\n|:-----------|---------:|:-----------------|---------------:|\n|KDFW        |    1.0000|KDFW              |          1.0000|\n|KDTW        |    0.9011|KDTW              |          0.5967|\n|KCLT        |    0.8776|KLAS              |          0.5553|\n|KLAS        |    0.8467|KCLT              |          0.5549|\n|KIAD        |    0.6419|KIAD              |          0.4430|\n|KTPA        |    0.4864|KORF              |          0.3059|\n|KTUL        |    0.4628|KU42              |          0.2988|\n|KORF        |    0.4533|KDAL              |          0.2758|\n|KCLE        |    0.4341|KTUL              |          0.2757|\n|KMKE        |    0.4055|KJFK              |          0.2474|\n\n\n:::\n:::\n\n\n### Comparing Centrality Measures\n\nDifferent centrality measures capture different aspects of importance. I wanted to see how correlated they are in this airport network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Pairwise centrality comparison\ncent_df <- data.frame(\n  airport = V(flight_undirected)$name,\n  degree = igraph::degree(flight_undirected),\n  betweenness = igraph::betweenness(flight_undirected),\n  eigenvector = igraph::eigen_centrality(flight_undirected)$vector,\n  strength = igraph::strength(flight_undirected)\n)\n\n## Pairwise scatter plots\npairs(cent_df[, c(\"degree\", \"betweenness\", \"eigenvector\", \"strength\")],\n      col = adjustcolor(\"steelblue\", alpha.f = 0.3),\n      pch = 19,\n      main = \"Pairwise Centrality Comparisons\",\n      labels = c(\"Degree\", \"Betweenness\", \"Eigenvector\", \"Strength\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/flight-centrality-pairs-1.png){width=960}\n:::\n:::\n\n\nDegree and strength are strongly correlated — airports with more routes generally also have more total flights. Eigenvector centrality is also positively associated with degree, but with more spread: some mid-degree airports score high on eigenvector centrality because they connect to the right hubs. Betweenness centrality shows the most interesting divergence. Some airports with moderate degree have disproportionately high betweenness because they serve as the sole bridge between regions of the network. These are the airports whose closure would most disrupt connectivity — potentially interesting from a resilience or infrastructure planning perspective.\n\n## Assortativity and Mixing Patterns\n\nFollowing Kolaczyk and Csárdi (2020, Sec. 4.5), I examined assortativity — the tendency for nodes to connect with similar (or dissimilar) nodes (Newman, 2002). For a continuous attribute like degree, the assortativity coefficient ranges from -1 (perfectly disassortative) to +1 (perfectly assortative).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Degree assortativity\ndeg_assort <- assortativity_degree(flight_undirected)\ncat(\"Degree assortativity coefficient:\", round(deg_assort, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDegree assortativity coefficient: -0.0353 \n```\n\n\n:::\n:::\n\n\nA negative assortativity coefficient confirms the disassortative mixing pattern I observed in the average neighbor degree plot. High-degree hubs preferentially connect to low-degree regional airports, and vice versa. This is the structural signature of a hub-and-spoke network: the major hubs serve as intermediaries for the many smaller airports that depend on them for connectivity to the broader network.\n\nThis stands in contrast to social networks, which tend to exhibit positive assortativity (people with many connections tend to be connected to others with many connections). Transportation and technological networks are typically disassortative, reflecting their functional architecture where central nodes serve peripheral ones.\n\n## Community Detection\n\nFollowing Kolaczyk and Csárdi (2020, Sec. 4.4), I applied community detection algorithms to partition the network into groups of densely interconnected airports. In an airport network, communities might correspond to geographic regions, airline alliances, or other structural groupings.\n\n### Hierarchical Clustering\n\nI began with hierarchical clustering using edge betweenness, which works by iteratively removing the edges with the highest betweenness (the edges that serve as bridges between communities).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Edge betweenness community detection\neb_comm <- cluster_edge_betweenness(flight_undirected)\ncat(\"Number of communities (edge betweenness):\", length(eb_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of communities (edge betweenness): 127 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", round(modularity(eb_comm), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.5007 \n```\n\n\n:::\n:::\n\n\n### Fast Greedy Modularity Optimization\n\nThe fast greedy algorithm directly optimizes modularity — the measure of how well a partition separates the network into groups with dense internal connections and sparse connections between groups.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfg_comm <- cluster_fast_greedy(flight_undirected)\ncat(\"Number of communities (fast greedy):\", length(fg_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of communities (fast greedy): 143 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", round(modularity(fg_comm), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.6182 \n```\n\n\n:::\n:::\n\n\n### Louvain Method\n\nThe Louvain algorithm is another modularity optimization method that works well for large networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlouv_comm <- cluster_louvain(flight_undirected)\ncat(\"Number of communities (Louvain):\", length(louv_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of communities (Louvain): 140 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", round(modularity(louv_comm), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.6209 \n```\n\n\n:::\n:::\n\n\n### Comparing Community Detection Results\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomm_comparison <- data.frame(\n  Method = c(\"Edge Betweenness\", \"Fast Greedy\", \"Louvain\"),\n  Communities = c(length(eb_comm), length(fg_comm), length(louv_comm)),\n  Modularity = c(round(modularity(eb_comm), 4),\n                 round(modularity(fg_comm), 4),\n                 round(modularity(louv_comm), 4))\n)\n\nkable(comm_comparison, col.names = c(\"Method\", \"Communities\", \"Modularity\"),\n      align = c(\"l\", \"r\", \"r\"),\n      caption = \"Community Detection Comparison\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Community Detection Comparison\n\n|Method           | Communities| Modularity|\n|:----------------|-----------:|----------:|\n|Edge Betweenness |         127|     0.5007|\n|Fast Greedy      |         143|     0.6182|\n|Louvain          |         140|     0.6209|\n\n\n:::\n:::\n\n\n### Visualizing Community Structure\n\nI used the Louvain partition (which typically achieves the highest modularity) to color the network visualization by community.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Ensure Louvain communities exist (e.g. if this chunk is run alone)\nif (!exists(\"louv_comm\")) louv_comm <- cluster_louvain(flight_undirected)\n\n## Compute degree-based sizing (needed for this plot)\ndeg_comm <- igraph::degree(flight_undirected)\nv_size_comm <- 1 + 4 * sqrt(deg_comm / max(deg_comm))\n\n## Louvain communities for visualization\nmem <- membership(louv_comm)\nn_comm <- max(mem)\n\n## Color palette for communities (base R so no extra package needed)\ncomm_palette <- if (n_comm <= 12) hcl.colors(n_comm, \"Pastel 1\") else rainbow(n_comm, alpha = 0.7)\ncomm_colors <- comm_palette[mem]\n\nset.seed(123)\nlayout_fr2 <- layout_with_fr(flight_undirected)\n\nplot(flight_undirected,\n     layout = layout_fr2,\n     vertex.size = v_size_comm,\n     vertex.color = comm_colors,\n     vertex.frame.color = NA,\n     vertex.label = ifelse(deg_comm >= quantile(deg_comm, 0.97), V(flight_undirected)$name, NA),\n     vertex.label.cex = 0.55,\n     vertex.label.color = \"black\",\n     edge.color = adjustcolor(\"gray60\", alpha.f = 0.1),\n     edge.arrow.size = 0,\n     edge.width = 0.2,\n     main = \"Flight Network Colored by Community (Louvain)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/flight-community-viz-1.png){width=1152}\n:::\n:::\n\n\n### Community Size Distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomm_sizes <- sizes(louv_comm)\nbarplot(sort(comm_sizes, decreasing = TRUE),\n        col = \"steelblue\",\n        xlab = \"Community\",\n        ylab = \"Number of Airports\",\n        main = \"Community Size Distribution (Louvain)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/flight-comm-sizes-1.png){width=672}\n:::\n:::\n\n\nThe community detection results reveal meaningful structure in the airport network, despite its hub-and-spoke topology. The modularity values are positive and moderate, indicating that the partitioning captures real groupings beyond what you would expect by chance. As the instructor noted, it was an open question whether community structure would emerge clearly in a hub-dominated network, and the results suggest it does — likely reflecting geographic clustering (airports in the same region are more interconnected) and possibly airline alliance or regulatory boundaries.\n\nThe different algorithms find somewhat different numbers of communities but broadly agree on the modularity, which gives us confidence that the structure is real rather than an artifact of any one algorithm. The community size distribution typically shows a few large communities (major geographic regions) and several smaller ones (isolated groups of regional airports).\n\n## Summary of Flight Network Analysis\n\n::: summary-highlight\nThis analysis of a random sample of 500 airports reveals the characteristic structure of a real-world transportation network. The degree distribution follows a power law (Barabási & Albert, 1999), with a few mega-hubs dominating the network while most airports have only a handful of connections. Centrality analysis identifies the airports that are most important by different criteria — degree centrality highlights the most connected hubs, betweenness centrality reveals the critical transfer points whose removal would most disrupt the network, and eigenvector centrality captures airports whose importance comes from connecting to other important airports. The network is disassortative (Newman, 2002), meaning hubs preferentially connect to smaller airports rather than to each other — the structural signature of hub-and-spoke architecture. Community detection uncovers meaningful groupings that likely correspond to geographic regions, and the moderate modularity values confirm that this structure is more pronounced than what would appear in a random network. Taken together, these analyses paint a picture of a network that is **efficient** (short average path lengths thanks to hubs), **unequal** (most connectivity concentrated in a few nodes), and **structurally organized** (clear community boundaries corresponding to real-world geography).\n:::\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}